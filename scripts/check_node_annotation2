#!/bin/bash

check_node_sichek_status() {
  local ready_only=false

  # å‚æ•°è§£æž
  while [[ $# -gt 0 ]]; do
    case "$1" in
      ready-only)
        ready_only=true
        ;;
    esac
    shift
  done

  # èŽ·å–æ‰€æœ‰èŠ‚ç‚¹åç§°
  kubectl get nodes --no-headers | awk '{print $1}' | while read -r node; do
    # èŽ·å– Ready çŠ¶æ€
    ready=$(kubectl get node "$node" -o jsonpath='{range .status.conditions[?(@.type=="Ready")]}{.status}{end}')
    
    # èŽ·å– unschedulable çŠ¶æ€
    unschedulable=$(kubectl get node "$node" -o jsonpath='{.spec.unschedulable}')
    [[ "$unschedulable" == "true" ]] || unschedulable="false"

    # èŽ·å– sichek annotation
    sichek=$(kubectl get node "$node" -o jsonpath='{.metadata.annotations.scitix\.ai/sichek}')
    
    # è·³è¿‡æ²¡æœ‰ "err" çš„èŠ‚ç‚¹
    if [[ "$sichek" != *err* ]]; then
      continue
    fi

    # --ready-only ä¸”ä¸æ˜¯ Ready æˆ– cordonedï¼Œè·³è¿‡
    if $ready_only && { [[ "$ready" != "True" ]] || [[ "$unschedulable" == "true" ]]; }; then
      continue
    fi

    # çŠ¶æ€æ ‡ç­¾
    if [[ "$ready" != "True" ]]; then
      ready_label=$(printf "\033[1;31mNotReady\033[0m")   # ðŸ”´
    elif [[ "$unschedulable" == "true" ]]; then
      ready_label=$(printf "\033[1;33mCordoned\033[0m")   # ðŸŸ¡
    else
      ready_label=$(printf "\033[1;32mReady\033[0m")      # ðŸŸ¢
    fi

    printf "%s [%s] -> %s\n" "$node" "$ready_label" "$sichek"
  done
}

check_node_sichek_status "$@"