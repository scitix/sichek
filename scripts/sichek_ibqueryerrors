#!/usr/bin/env python3
import subprocess
import re
import time
import threading
import tempfile
import os
from typing import Dict, Tuple, List
from collections import defaultdict
# from prometheus_client import Gauge, start_http_server

# # Prometheus metric
# IB_ERROR_COUNTER = Gauge(
#     "ib_port_error_counter",
#     "IB Port Error Counter from ibqueryerrors",
#     ["guid", "port", "error"]
# )

def parse_iblinkinfo_for_topology():
    """
    è§£æ iblinkinfo è¾“å‡ºæ¥è·å–æ‹“æ‰‘ä¿¡æ¯
    è¿”å›: (switches, groups) å…¶ä¸­ switches åŒ…å«ç±»å‹ä¿¡æ¯ï¼Œgroups æ˜¯åˆ†ç»„ä¿¡æ¯
    """
    switches = {}
    hosts = {}

    # åˆ›å»ºä¸´æ—¶æ–‡ä»¶æ¥å­˜å‚¨ iblinkinfo è¾“å‡º
    with tempfile.NamedTemporaryFile(mode='w', delete=False, suffix='.txt') as tmp_file:
        tmp_path = tmp_file.name

    try:
        # è¿è¡Œ iblinkinfo å¹¶ä¿å­˜åˆ°ä¸´æ—¶æ–‡ä»¶
        result = subprocess.run(
            ['iblinkinfo', '--switches-only'],
            stdout=open(tmp_path, 'w'),
            stderr=subprocess.PIPE,
            text=True
        )

        if result.returncode != 0:
            print(f"[âš ï¸ Warning] iblinkinfo failed with return code {result.returncode}")
            return {}, {}

        # è§£ææ–‡ä»¶
        switches, hosts = parse_iblinkinfo_file(tmp_path)

    except Exception as e:
        print(f"[âš ï¸ Warning] Failed to parse topology: {e}")
        return {}, {}
    finally:
        # æ¸…ç†ä¸´æ—¶æ–‡ä»¶
        if os.path.exists(tmp_path):
            os.unlink(tmp_path)

    # åˆ†ç±»æ‹“æ‰‘
    topo = classify_topology(switches, hosts)

    # åˆ†ç»„ leaf switches
    groups = group_leaf_switches_by_hosts(switches)

    return switches, groups

def parse_iblinkinfo_file(file_path: str):
    """è§£æ iblinkinfo è¾“å‡ºæ–‡ä»¶"""
    switches = {}
    hosts = {}

    sw_re = re.compile(r'^Switch:\s+(\S+)\s+(.*):$')
    port_re = re.compile(
        r'^\s*(\d+)\s+(\d+)\[.*?\]\s+==\(\s*(.*?)\s*\)==>\s*(\S*)\s*(\d*)\[.*?\]\s+"(.*?)"\s*\(.*\)'
    )

    current_sw = None

    with open(file_path, "r") as f:
        for line in f:
            line = line.rstrip()

            # Switch èµ·å§‹è¡Œ
            m = sw_re.match(line)
            if m:
                sw_guid, sw_name = m.groups()
                current_sw = {
                    "guid": sw_guid,
                    "name": sw_name,
                    "lid": None,
                    "ports": [],
                    "total_ports": 0,
                    "up_ports": 0,
                    "down_ports": 0,
                }
                switches[sw_guid] = current_sw
                continue

            # ç«¯å£è¡Œ
            m = port_re.match(line)
            if m and current_sw:
                lid, port, state, peer_lid, peer_port, peer_name = m.groups()

                if current_sw["lid"] is None:
                    current_sw["lid"] = int(lid)

                peer_type = "unknown"
                name_lower = peer_name.lower()
                if "switch" in name_lower:
                    peer_type = "switch"
                elif "mlx5" in name_lower or "connectx" in name_lower:
                    peer_type = "hca"

                port_info = {
                    "port": int(port),
                    "state": state.strip(),
                    "peer": {
                        "lid": peer_lid if peer_lid else None,
                        "port": int(peer_port) if peer_port else None,
                        "name": peer_name.strip(),
                        "type": peer_type,
                    } if peer_name else None
                }
                current_sw["ports"].append(port_info)

                # å¦‚æœæ˜¯ HCAï¼ŒæŠŠ host è®°å½•ä¸‹æ¥
                if peer_type == "hca":
                    peer_parts = peer_name.split()
                    host_id = peer_parts[0]
                    hca_name = peer_parts[1] if len(peer_parts) > 1 else "unknown"

                    if host_id not in hosts:
                        hosts[host_id] = {
                            "id": host_id,
                            "ports": []
                        }
                    hosts[host_id]["ports"].append({
                        "switch": current_sw["guid"],
                        "switch_port": int(port),
                        "state": state.strip(),
                        "node_name": host_id,
                        "hca_name": hca_name,
                        "full_name": peer_name
                    })

    # è®¡ç®—æ¯ä¸ªäº¤æ¢æœºçš„ç«¯å£ç»Ÿè®¡ä¿¡æ¯
    for sw_id, sw in switches.items():
        total = len(sw["ports"])
        up = sum(1 for p in sw["ports"] if "LinkUp" in p["state"])
        down = total - up

        sw["total_ports"] = total
        sw["up_ports"] = up
        sw["down_ports"] = down

    return switches, hosts

def classify_topology(switches: dict, hosts: dict):
    """åˆ†ç±»æ‹“æ‰‘ç»“æ„ï¼šLeaf / Spine / Superspine / Interconnect"""
    leaf_sw, spine_sw, superspine_sw, interconnect_sw = [], [], [], []

    # ç¬¬ä¸€æ­¥ï¼šè¯†åˆ«Leaf Switchï¼ˆè¿æ¥HCAçš„äº¤æ¢æœºï¼‰
    for sw_id, sw in switches.items():
        hca_ports = [p for p in sw["ports"] if p.get("peer") and p.get("peer").get("type") == "hca"]
        if hca_ports:
            sw["type"] = "leaf_sw"
            leaf_sw.append(sw)

    # ç¬¬äºŒæ­¥ï¼šè¯†åˆ«è¿æ¥åˆ°Leaf Switchçš„äº¤æ¢æœºï¼ˆè¿™äº›æ˜¯Spine Switchï¼‰
    leaf_names = {sw["name"] for sw in leaf_sw}
    for sw_id, sw in switches.items():
        if sw.get("type") == "leaf_sw":
            continue

        connected_to_leaf = False
        for p in sw["ports"]:
            if p.get("peer") and p["peer"].get("name") in leaf_names:
                connected_to_leaf = True
                break

        if connected_to_leaf:
            sw["type"] = "spine_sw"
            spine_sw.append(sw)

    # ç¬¬ä¸‰æ­¥ï¼šè¯†åˆ«Superspine Switchï¼ˆè¿æ¥åˆ°Spine Switchçš„äº¤æ¢æœºï¼‰
    spine_names = {sw["name"] for sw in spine_sw}
    for sw_id, sw in switches.items():
        if sw.get("type") in ["leaf_sw", "spine_sw"]:
            continue

        connected_to_spine = False
        for p in sw["ports"]:
            if p.get("peer") and p["peer"].get("name") in spine_names:
                connected_to_spine = True
                break

        if connected_to_spine:
            sw["type"] = "superspine_sw"
            superspine_sw.append(sw)

    # ç¬¬å››æ­¥ï¼šè¯†åˆ«Interconnect Switch
    for sw_id, sw in switches.items():
        if sw.get("type") in ["leaf_sw", "spine_sw", "superspine_sw"]:
            continue

        has_hca = any(p.get("peer") and p["peer"].get("type") == "hca" for p in sw["ports"])
        if not has_hca:
            sw["type"] = "interconnect_sw"
            interconnect_sw.append(sw)

    return {
        "leaf_sw": leaf_sw,
        "spine_sw": spine_sw,
        "superspine_sw": superspine_sw,
        "interconnect_sw": interconnect_sw,
    }

def group_leaf_switches_by_hosts(switches: dict):
    """æ ¹æ®Leaf Switchè¿æ¥çš„hostè¿›è¡Œåˆ†ç»„"""
    leaf_switches = [sw for sw in switches.values() if sw.get("type") == "leaf_sw"]

    # æ”¶é›†æ¯ä¸ªLeaf Switchçš„Hosté›†åˆ
    leaf_hosts = {}
    for sw in leaf_switches:
        hosts = set()
        for p in sw["ports"]:
            peer = p.get("peer")
            if peer and peer.get("type") == "hca":
                if "Mellanox Technologies" in peer["name"]:
                    continue
                host = peer["name"].split()[0]
                hosts.add(host)
        leaf_hosts[sw["guid"]] = hosts

    # æ ¹æ®hosté›†åˆåˆ†ç»„
    groups = defaultdict(list)
    for sw_guid, hosts in leaf_hosts.items():
        host_key = tuple(sorted(hosts))
        groups[host_key].append(sw_guid)

    # è¿‡æ»¤æ‰ç©ºç»„
    groups = {k: v for k, v in groups.items() if k}

    return groups

def get_switch_info(guid: str, switches: dict, groups: dict) -> Tuple[str, str]:
    """
    è·å–äº¤æ¢æœºä¿¡æ¯
    è¿”å›: (type_info, group_info)
    """
    if guid not in switches:
        return "unknown", "unknown"

    sw = switches[guid]
    switch_type = sw.get("type", "unknown")

    if switch_type == "leaf_sw":
        # æŸ¥æ‰¾è¿™ä¸ª leaf switch å±äºå“ªä¸ªç»„
        for group_id, (hosts, sw_guids) in enumerate(groups.items(), 1):
            if guid in sw_guids:
                return "leaf", f"group-{group_id}"
        return "leaf", "ungrouped"
    elif switch_type == "spine_sw":
        return "spine", "spine"
    elif switch_type == "superspine_sw":
        return "superspine", "superspine"
    elif switch_type == "interconnect_sw":
        return "interconnect", "interconnect"
    else:
        return "unknown", "unknown"

# === é‡‡é›†å‡½æ•° ===
def run_ibqueryerrors() -> Dict[str, Dict[str, Dict[str, int]]]:
    try:
        result = subprocess.run(
            ["ibqueryerrors", "-e", "--data", "--switch"],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True
        )

        # ibqueryerrors returns 1 when errors are found (normal behavior)
        if result.returncode not in [0, 1]:
            print(f"[âŒ Error] ibqueryerrors failed with return code {result.returncode}")
            if result.stderr:
                print(f"Error output: {result.stderr}")
            return {}

    except Exception as e:
        print(f"[âŒ Error] Failed to run ibqueryerrors: {e}")
        return {}

    output = result.stdout
    results = {}
    guid_line_re = re.compile(r"^GUID\s+(0x[0-9a-fA-F]+)\s+port\s+(\d+|ALL):\s*(.*)")
    kv_pair_re = re.compile(r"\[([A-Za-z0-9_]+)\s*==\s*(\d+)")

    for line in output.splitlines():
        line = line.strip()
        if not line.startswith("GUID"):
            continue
        m = guid_line_re.match(line)
        if m:
            guid, port, rest = m.groups()
            results.setdefault(guid, {})
            results[guid].setdefault(port, {})
            for key, val in kv_pair_re.findall(rest):
                results[guid][port][key] = int(val)

    return results

# === ä¸ŠæŠ¥ Prometheus æŒ‡æ ‡ ===
#def update_prometheus_metrics(data: Dict[str, Dict[str, Dict[str, int]]]):
#    for guid, ports in data.items():
#        for port, counters in ports.items():
#            for name, value in counters.items():
#                IB_ERROR_COUNTER.labels(guid=guid, port=port, error=name).set(value)

# === æ’åºå¹¶è¾“å‡ºæŠ¥å‘Š ===
def generate_reports(data: Dict[str, Dict[str, Dict[str, int]]], linkdown_threshold=10):
    # è·å–æ‹“æ‰‘ä¿¡æ¯
    switches, groups = parse_iblinkinfo_for_topology()

    print("\n==== ğŸ” LinkDownedCounter Top Switches (port ALL) ====")
    rows = []
    for guid, ports in data.items():
        all_port = ports.get("ALL", {})
        cnt = all_port.get("LinkDownedCounter", 0)
        switch_type, group_info = get_switch_info(guid, switches, groups)
        rows.append((guid, cnt, switch_type, group_info))
    rows.sort(key=lambda x: x[1], reverse=True)
    for guid, count, switch_type, group_info in rows:
        type_display = f"[{switch_type}]" if switch_type != "unknown" else "[unknown]"
        group_display = f"({group_info})" if group_info != "unknown" else ""
        print(f"{guid:24}  {type_display:12} {group_display:15} LinkDownedCounter: {count}")

    print("\n==== ğŸ” LinkDownedCounter Top Ports ====")
    port_rows = []
    for guid, ports in data.items():
        for port, counters in ports.items():
            if port == "ALL":
                continue
            cnt = counters.get("LinkDownedCounter", 0)
            switch_type, group_info = get_switch_info(guid, switches, groups)
            port_rows.append((guid, port, cnt, switch_type, group_info))
    port_rows.sort(key=lambda x: x[2], reverse=True)
    for guid, port, count, switch_type, group_info in port_rows[:10]:
        type_display = f"[{switch_type}]" if switch_type != "unknown" else "[unknown]"
        group_display = f"({group_info})" if group_info != "unknown" else ""
        print(f"{guid} port {port:>2}  {type_display:12} {group_display:15} LinkDownedCounter: {count}")

    print("\n==== ğŸš¨ Alerts: Port LinkDownedCounter > threshold ====")
    alert_rows = []
    for guid, ports in data.items():
        for port, counters in ports.items():
            if port == "ALL":
                continue
            cnt = counters.get("LinkDownedCounter", 0)
            if cnt > linkdown_threshold:
                switch_type, group_info = get_switch_info(guid, switches, groups)
                alert_rows.append((guid, port, cnt, switch_type, group_info))

    # æŒ‰ LinkDownedCounter å€¼ä»é«˜åˆ°ä½æ’åº
    alert_rows.sort(key=lambda x: x[2], reverse=True)

    for guid, port, count, switch_type, group_info in alert_rows:
        type_display = f"[{switch_type}]" if switch_type != "unknown" else "[unknown]"
        group_display = f"({group_info})" if group_info != "unknown" else ""
        print(f"[ALERT] {guid} port {port} {type_display:12} {group_display:15} â†’ LinkDownedCounter = {count}")

# === ä¸»é€»è¾‘å¾ªç¯ ===
# def run_exporter(interval_sec=60, port=9384):
#     start_http_server(port)
#     print(f"ğŸš€ Prometheus exporter started at :{port}, polling every {interval_sec}s")

#     def loop():
#         while True:
#             data = run_ibqueryerrors()
#             update_prometheus_metrics(data)
#             generate_reports(data)
#             time.sleep(interval_sec)

#     threading.Thread(target=loop, daemon=True).start()

# === å…¥å£ ===
if __name__ == "__main__":
    # run_exporter(interval_sec=60, port=9384)
    # while True:
    #     time.sleep(3600)  # ä¸»çº¿ç¨‹é˜»å¡

    data = run_ibqueryerrors()
    #update_prometheus_metrics(data)
    generate_reports(data)
